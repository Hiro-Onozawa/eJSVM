#!/usr/bin/ruby

header_type   = "uint64_t"
bytes_in_word = 8
bits_in_byte  = 8
header_words  = 1
header_magic  = 0x18
header_def = [
  [ 0,  7, "TYPE",   :param, "type of memory chunk"],
  [ 8,  8, "GC",     nil,     "GC mark bit"],
  [ 9, 11, "EXTRA",  :param, "number of unused words attached at the bottom"+
                             " of this chunk"],
  [12, 15, "GEN",    nil,    "generation"],
#  [16, 23, "MAGIC",  "HEADER0_MAGIC",    "magic"],
  [16, 23, "MAGIC",  nil,    "magic"],
  [32, 63, "SIZE",   :param, "number of words of this chunk including header"]
];

####################################################################

print <<END
/****
 * cell_header.h  --  definition of the cell header.
 * !!!!!
 * !!!!! DO NOT EDIT THIS FILE.
 * !!!!!   This file is generated from cell_header.def.
 * !!!!!
 *
 * HEADER  : The entire header.
 * HEADER0 : The primary word of the header.
 *
 * header_t: The type of HEADER0.
 *
 * field definition
 *   HEADER0_xxx_OFFSET
 *   HEADER0_xxx_BITS
 *   HEADER0_xxx_MASK
 * field accessor
 *   HEADER0_SET_xxx(hdr, val)       : hdr.xxx := val
 *   HEADER0_SET_xxx_MASK(hdr, val)  : hdr.xxx := val (val may be truncated)
 *   HEADER0_GET_xxx(hdr)            : gives hdr.xxx
 *
 * HEADER0_COMPOSE(...)  : gives initial value for the HEADER0.
 *                         (See the definition below for the argements.)
 */
END

def define(name, val)
  print "#define #{name} (#{val.to_s})\n"
end

def undefine(name)
  print "#undef #{name}\n"
end

def section_start(desc)
  print <<END

/*
 * #{desc}
 */

END
end

compose = []
compose_params = []

section_start("general definition")
print "typedef #{header_type} header_t;\n"
define("HEADER_JSVALUES", header_words)
define("HEADER_BYTES",    header_words * bytes_in_word)
define("HEADER0_BITS",    bytes_in_word * bits_in_byte)
define("HEADER0_MAGIC", sprintf("0x%x", header_magic))

section_start("internal macros")
define("__MKMSK(l, o, b)\\\n",
       "((((header_t) -1) << ((l) - (b))) >> ((l) - (o) - (b)))")
define("__HEADER0_SET(hdr, val, off, msk)",
       "(hdr) = ((((header_t) (val)) << (off)) | ((hdr) & ~(msk)))");
define("__HEADER0_SET_MASK(hdr, val, off, msk)",
       "(hdr) = (((((header_t) (val)) << (off)) & (msk)) | ((hdr) & ~(msk)))");
define("__HEADER0_GET(hdr, off, msk)",
       "(((uint64_t) ((hdr) & (msk))) >> (off))");


section_start("field definition");
header_def.each do |s, e, name, c, desc|
  offset = "HEADER0_#{name}_OFFSET"
  bits   = "HEADER0_#{name}_BITS"
  mask   = "HEADER0_#{name}_MASK"
  setter = "HEADER0_SET_#{name}(hdr,val)"
  setterm= "HEADER0_SET_#{name}_MASK(hdr,val)"
  getter = "HEADER0_GET_#{name}(hdr)"
  # bit field
  define(offset, s.to_s);
  define(bits, (e - s + 1).to_s);
  # mask
  define(mask, "__MKMSK(HEADER0_BITS, #{offset}, #{bits})")
  # accessor
  define(setter, "__HEADER0_SET((hdr), (val), #{offset}, #{mask})")
  define(setterm, "__HEADER0_SET_MASK((hdr), (val), #{offset}, #{mask})")
  define(getter, "__HEADER0_GET((hdr), #{offset}, #{mask})")

  if c then
    if c == :param then
      param_name = name.downcase
      compose_params.unshift(param_name)
      compose.unshift("(((header_t) (#{param_name})) << #{offset})")
    else
      compose.unshift("(((header_t) (#{c})) << #{offset})")
    end
  end
end

section_start("initialisation")
params = compose_params.join(",")
define("HEADER0_COMPOSE(#{params}) \\\n",
       compose.join(" | \\\n  "))
