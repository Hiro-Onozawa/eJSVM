#!/usr/bin/ruby

header_type   = ""
bytes_in_word = 0
bits_in_byte  = 0
header_magic  = 0x0
header_def = [];

if (ARGV.size < 2) then
  raise "Usage : <basebit> <gc algorithm>"
end

is_debug = (ARGV[0] == "true")
basebit = ARGV[1]
gc_algorithm = ARGV[2]

if (basebit == "64") then
  header_type   = "uint64_t"
  bytes_in_word = 8
  bits_in_byte  = 8
  header_magic  = 0x18
  case gc_algorithm
  when "mark_sweep" then
    header_def.push([
      [ 0,  7, "TYPE",   :param, "type of memory chunk"],
      [ 8,  8, "GC",     nil,    "GC mark bit"],
      [ 9, 11, "EXTRA",  :param, "number of unused words attached at the bottom"+
                                 " of this chunk"],
      [12, 15, "GEN",    nil,    "generation"],
    #  [16, 23, "MAGIC",  "HEADER0_MAGIC",    "magic"],
      [16, 23, "MAGIC",  nil,    "magic"],
      [32, 63, "SIZE",   :param, "number of words of this chunk including header"]
    ]);
  when "mark_compact" then
    header_def.push([
      [ 0,  7, "TYPE",   :param, "type of memory chunk"],
      [ 8,  8, "GC",     nil,    "GC mark bit"],
      [ 9, 12, "GEN",    nil,    "generation"],
      [13, 20, "MAGIC",  nil,    "magic"],
      [32, 63, "SIZE",   :param, "number of words of this chunk including header"]
    ]);
  when "threaded_compact" then
    header_def.push([
      [ 0,  0, "MARK",   1,      "mark bit of header word"],
      [ 1,  7, "TYPE",   :param, "type of memory chunk"],
      [ 8,  8, "GC",     nil,    "GC mark bit"],
      [32, 63, "SIZE",   :param, "number of words of this chunk including header"]
    ]);
    if (is_debug) then
      header_def[0].push(
        [ 9, 12, "GEN",    nil,    "generation"],
        [13, 20, "MAGIC",  nil,    "magic"]
      )
    end
  when "copy" then
    header_def.push([
      [ 0,  7, "TYPE",   :param, "type of memory chunk"],
      [ 8, 11, "GEN",    nil,    "generation"],
    #  [13, 20, "MAGIC",  "HEADER0_MAGIC",    "magic"],
      [12, 19, "MAGIC",  nil,    "magic"],
      [32, 63, "SIZE",   :param, "number of words of this chunk including header"]
    ]);
  end
elsif (basebit == "32") then
  header_type   = "uint32_t"
  bytes_in_word = 4
  bits_in_byte  = 8
  header_magic  = 0x18
  case gc_algorithm
  when "mark_sweep" then
    header_def.push([
      [0,  4, "TYPE",  :param, "type of memory chunk"],
      [5,  5, "GC",    nil,    "GC mark bit"],
      [6,  7, "EXTRA", :param, "number of unused words attached at the bottom"+
                               " of this chunk"],
      [8, 31, "SIZE",  :param, "number of words of this chunk including header"]
    ]);
  when "mark_compact" then
    header_def.push([
      [0,  4, "TYPE",  :param, "type of memory chunk"],
      [5,  5, "GC",    nil,    "GC mark bit"],
      [6, 31, "SIZE",  :param, "number of words of this chunk including header"]
    ]);
  when "threaded_compact" then
    header_def.push([
      [0,  0, "MARK",  1,      "mark bit of header word"],
      [1,  5, "TYPE",  :param, "type of memory chunk"],
      [6,  6, "GC",    nil,    "GC mark bit"],
      [7, 31, "SIZE",  :param, "number of words of this chunk including header"]
    ]);
  when "copy" then
    header_def.push([
      [0,  4, "TYPE",  :param, "type of memory chunk"],
      [5, 31, "SIZE",  :param, "number of words of this chunk including header"]
    ]);
  end
  if (is_debug) then
    header_def.push(
      [
        [0,  3, "GEN",   nil,    "generation"],
        [4, 11, "MAGIC", nil,    "magic"]
      ]
    )
  end
else
  raise "Invalid basebit value : " + basebit
end

if (gc_algorithm == "mark_sweep") then
  # Nothing to do
elsif (gc_algorithm == "mark_compact") then
  header_def.push(
    [
      [ 0, bytes_in_word * bits_in_byte - 1, "FWD", :param, "fowarding pointer"]
    ]
  );
elsif (gc_algorithm == "threaded_compact") then
  # Nothing to do
elsif (gc_algorithm == "copy") then
  # Nothing to do
else
  raise "Invalid gc algorithm value : " + gc_algorithm
end

####################################################################

print <<END
/****
 * cell_header.h  --  definition of the cell header.
 * !!!!!
 * !!!!! DO NOT EDIT THIS FILE.
 * !!!!!   This file is generated from cell_header.def.
 * !!!!!
 *
 * HEADER  : The entire header.
 * HEADER0 : The primary word of the header.
 *
 * header_word_t: The type of HEADER0.
 *
 * field definition
 *   HEADER0_xxx_OFFSET
 *   HEADER0_xxx_BITS
 *   HEADER0_xxx_MASK
 * field accessor
 *   HEADER0_SET_xxx(hdr, val)       : hdr.xxx := val
 *   HEADER0_SET_xxx_MASK(hdr, val)  : hdr.xxx := val (val may be truncated)
 *   HEADER0_GET_xxx(hdr)            : gives hdr.xxx
 *
 * HEADER0_COMPOSE(...)  : gives initial value for the HEADER0.
 *                         (See the definition below for the argements.)
 */
END

def define(name, val)
  print "#define #{name} (#{val.to_s})\n"
end

def undefine(name)
  print "#undef #{name}\n"
end

def section_start(desc)
  print <<END

/*
 * #{desc}
 */

END
end

compose = []
compose_params = []

section_start("general definition")
print "typedef #{header_type} header_word_t;\n"
print "typedef struct header_cell {\n"
header_def.size.times do |cnt|
  print "  header_word_t header#{cnt};\n"
end
print "} HeaderCell;\n"
define("HEADER_BYTES",  bytes_in_word * header_def.size)
define("HEADER_WORD_BITS",  bytes_in_word * bits_in_byte)
define("HEADER_BITS",  bytes_in_word * bits_in_byte)
define("HEADER_MAGIC", sprintf("0x%x", header_magic))

section_start("general macros")
define("VALPTR_TO_HEADERPTR(valptr)", "((HeaderCell *)((uintptr_t)(valptr) - HEADER_BYTES))")
define("HEADERPTR_TO_VALPTR(headerptr)", "((void *)((uintptr_t)(headerptr) + HEADER_BYTES))")

section_start("internal macros")
define("__MKMSK(l, o, b)\\\n",
       "((((header_word_t) -1) << ((l) - (b))) >> ((l) - (o) - (b)))")
define("__HEADER_SET(hdr, val, off, msk)",
       "(hdr) = ((((header_word_t) (val)) << (off)) | ((hdr) & ~(msk)))");
define("__HEADER_SET_MASK(hdr, val, off, msk)",
       "(hdr) = (((((header_word_t) (val)) << (off)) & (msk)) | ((hdr) & ~(msk)))");
define("__HEADER_GET(hdr, off, msk)",
       "(((header_word_t) ((hdr) & (msk))) >> (off))");


section_start("field definition");
header_def.each_with_index do |fields, index|
  compose.push([]);
  compose_params.push([]);
  fields.each do |s, e, name, c, desc|
    word    = "HEADER_#{name}_GET_WORD(hdrp)"
    offset  = "HEADER_#{name}_OFFSET"
    bits    = "HEADER_#{name}_BITS"
    mask    = "HEADER_#{name}_MASK"
    setter  = "HEADER_SET_#{name}(hdrp,val)"
    setterm = "HEADER_SET_#{name}_MASK(hdrp,val)"
    getter  = "HEADER_GET_#{name}(hdrp)"
    wgetter = "HEADERW_GET_#{name}(hdrw)"

    define(word, "(hdrp)->header#{index}");
    # bit field
    define(offset, s.to_s);
    define(bits, (e - s + 1).to_s);
    # mask
    define(mask, "__MKMSK(HEADER_WORD_BITS, #{offset}, #{bits})")
    # accessor
    define(setter, "__HEADER_SET((hdrp)->header#{index}, (val), #{offset}, #{mask})")
    define(setterm, "__HEADER_SET_MASK((hdrp)->header#{index}, (val), #{offset}, #{mask})")
    define(getter, "__HEADER_GET((hdrp)->header#{index}, #{offset}, #{mask})")
    define(wgetter, "__HEADER_GET(hdrw, #{offset}, #{mask})")

    if c then
      if c == :param then
        param_name = name.downcase
        compose_params[index].unshift(param_name)
        compose[index].unshift("(((header_word_t) (#{param_name})) << #{offset})")
      else
        compose[index].unshift("(((header_word_t) (#{c})) << #{offset})")
      end
    end
  end
end

section_start("initialisation")
initializer_list = []
initializer = "\\\n"
header_def.size.times do |index|
  params = compose_params[index].join(",")
  if (params == "") then
    define("HEADER#{index}_COMPOSE(#{params}) \\\n", "0")
  else
    define("HEADER#{index}_COMPOSE(#{params}) \\\n",
        compose[index].join(" | \\\n  "))
  end

  if (params != "") then initializer_list.push(params) end
  initializer += "    __hdrp->header#{index} = HEADER#{index}_COMPOSE(#{params});\\\n"
end
print "#define HEADER_COMPOSE(hdrp,#{initializer_list.join(",")}) \\\n"
print "  do {\\\n    HeaderCell* __hdrp = (HeaderCell *)(hdrp);#{initializer}  } while (0)\n"
